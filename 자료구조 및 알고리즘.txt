선형 자료구조 -리스트  - 배열
		     - 벡터 : "주소"가 연속으로 이루어져 있음/탐색에는 빠르나, 삽입삭제가 상대적으로 느림.
                  - 연결리스트: 노드의 다음 포인터가 다음노드를 연결시킴/ 번호 사이에 새로운 노드를 끼워 넣기가 편함.
                  - 스택 : 배열/연결리스트로 구현이 가능, 함수의 지역 변수 혹은 돌아갈 주소에 사용할 때 Stack frame을 사용하는 것이다. 
		    함수들은 전부 Stack을 사용하며, 재귀함수를 추적할 때 Stack이 적합하다. 입력된 자료의 순서를 뒤집을 때 사용!
                  - 큐 : 배열로 구성할 경우 포인터를 통해 Front과 Rear를 정한다.Rear을 뒤로 보내어 순환 시켜준다
		  순환 :  배열을 사용하여 단편화 문제x  링크드 리스트 배열 : 단편화 문제가 발생한다.
		  Update 단계에서 메세지들을 순차적으로 처리하기 위해 사용

		            **메모리 단편화 - RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 사용가능한 
			메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태를 보고 메모리 단편화가 발생했다고 한다.
			메모리 단편화는 내부 단편화와 외부 단편화로 구분 가능하다.
				내부 단편화(Internal Fragmentation)
					메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 
					메모리 공간이 낭비 되는 상황* 예를 들어 메모장을 켰는데 OS가 4kb를 할당해줬다. 
`					그런데 사실상 1kb만큼만 사용하고 있을 때 필요 이상으로 프로세스가 메모리를 할당받았으므로 내부 단편화가 3kb만큼 생긴 것임.
`				외부 단편화(External Fragmentation)
					 메모리가 할당되고 해제되는 작업이 반복될 때 작은 메모리가 중간중간 존재하게 된다. 이 때 중간중간에 생긴 사용하지 않는
				  	 메모리가 많이 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황* 예를 들어 
					 메모리 처음 주소에 8mb짜리 프로세스가 할당되었고 바로 이어서 16mb짜리 프로세스가 할당되었다고 가정했을 때
					 8mb짜리 프로세스를 종료시키면 메모리 처음 주소부터 8mb만큼 공간이 생긴다.

                  - 데큐
비선형 자료구조 - 트리    -일반 : Left Child- Right Sibling
		        -**이진 : 자식을 두개 까지만 가질 수 있는 트리, 수식을 트리형태를 표현한 수식 2진트리, 데이터를 빠르게 탐색하는 2진 탐색트리
			     포화 이진트리(Full Binary Tree) : 자식까지 다 차있는 트리
			     완전이진 트리(Complete Binary Tree) : 왼쪽 부터 채워져가는 트리의 형태/왼쪽부터 채워져야 속도가 빠르다.

			     높이 균형 트리 : 왼쪽과 오른쪽의 깊이가 1차이만 있는 경우
			     완전 높이 균형 트리 : 깊이 차이가 없는 경우
			     *전위,중위 순위, 후위순위(후위표기)-중위->후위로 바꾸는거는 기술시험에 나옴.
				전위 : 일반적인 트리의 내용을 읽을 때
				중위 : 연산
				후위 : 후위연산으로 바꾸는 식-밑에서 부터 데이터가 쌓이며, 값을 누적시킬때도 사용한다.
		       -수식 트리 : 후위 표기로 된 수식을 오른쪽에서 부터 왼쪽으로 읽어들인다.
			           수식에서 제일 오른쪽에 있는 연산자가 루트 노드가 된다.
				-후위 표기에서 항상 제일 오른쪽에 있는 토큰은 항상 연산자이다.
                  		          토큰이 연산자라면 가지노드이며, 다음에 따라 나오는 2개의 토큰은 오른쪽과 왼쪽의 자식 노드이다.
  			          단, 다음 토큰이 연속해서 연산자라면 이 토큰을 통해 만들어지는 하위 트리가 완성된 이후에 읽어낸 토큰이 왼쪽 자식 노드가 됨.
                                              토큰이 숫자라면 리프 노드이다.
	         - 그래프 - 방향성
		        - 무방향성

파일 - 직접
      - 순차
      - 색인순차

템플릿 : 생성시에 해당 함수에 붙혀넣기 된다.
/인라인 함수와 템플릿 함수는 호출부에 정의부를 복사해서 실행
메모리 관련해서 생성자-제거자 , 생성-삭제를 같이 만드는게 좋다 : 메모리 릭-개발자가 의도하지 않은 메모리를 점유하고 있는 현상\

+트리 : Root(뿌리), Branch(가지), Leaf (잎) 으로 나뉜다.
(A(B(C)(D(E)(F)))... 중첩괄호 방식
Left Child- Right Sibling 방식: 노드의 갯수 제한이 없는 트리 방식임. 왼쪽 자식 오른쪽에 형제 

분리집합 : 공통적인 요소가 없는 집합. 그룹에 대해 알 수 있게됨.

정렬 알고리즘 : 버블정렬 알고리즘
	       삽입정렬 : 하나씩 꺼내서 다룬다.
                    **실제 실무에서는 퀵정렬을 사용함. : 분할 정복 -분할해서 정복해 간다.
		 퀵소트에서 가장 효율이 안좋은 O(n^2)이 나오는 상황은 뭔가? =>이미 정렬이 완료된 상황입니다.

